import {
  JapavelSchema,
  getNormalizedFields,
  FieldDefinition,
  ApiConfig,
  ViewConfig,
  Relationship,
} from "./parser";

/**
 * Code Generator - Transforms JapavelSchema DSL to TypeScript/Prisma code
 */

export interface GeneratedCode {
  zodSchema: string;
  trpcRouter: string;
  prismaModel: string;
  reactComponent: string;
  types: string;
}

/**
 * Generate all code artifacts from a JapavelSchema
 */
export const generateAll = (schema: JapavelSchema): GeneratedCode => {
  return {
    zodSchema: generateZodSchema(schema),
    trpcRouter: generateTrpcRouter(schema),
    prismaModel: generatePrismaModel(schema),
    reactComponent: generateReactComponent(schema),
    types: generateTypes(schema),
  };
};

/**
 * Generate Zod schema from DSL
 */
export const generateZodSchema = (schema: JapavelSchema): string => {
  const fields = getNormalizedFields(schema);
  const model = schema.Model;

  const fieldLines = Object.entries(fields)
    .map(([name, field]) => `  ${name}: ${fieldToZod(field)},`)
    .join("\n");

  return `import { z } from 'zod';

/**
 * ${model} Schema
 * @generated by Japavel DSL Compiler
 */
export const ${model}Schema = z.object({
${fieldLines}
});

export type ${model} = z.infer<typeof ${model}Schema>;

// Input schema for creation (excludes auto-generated fields)
export const Create${model}InputSchema = ${model}Schema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type Create${model}Input = z.infer<typeof Create${model}InputSchema>;

// Input schema for updates (partial with required id)
export const Update${model}InputSchema = ${model}Schema.partial().required({ id: true });

export type Update${model}Input = z.infer<typeof Update${model}InputSchema>;

// Query input for filtering/searching
export const ${model}QuerySchema = z.object({
  page: z.number().int().min(1).default(1),
  limit: z.number().int().min(1).max(100).default(20),
  sortBy: z.string().optional(),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
  search: z.string().optional(),
});

export type ${model}Query = z.infer<typeof ${model}QuerySchema>;
`;
};

/**
 * Convert field definition to Zod type string
 */
function fieldToZod(field: FieldDefinition): string {
  let zodType: string;

  switch (field.type) {
    case "string":
      zodType = "z.string()";
      if (field.minLength) zodType += `.min(${field.minLength})`;
      if (field.maxLength) zodType += `.max(${field.maxLength})`;
      if (field.pattern) zodType += `.regex(/${field.pattern}/)`;
      break;
    case "number":
      zodType = "z.number()";
      if (field.min !== undefined) zodType += `.min(${field.min})`;
      if (field.max !== undefined) zodType += `.max(${field.max})`;
      break;
    case "int":
      zodType = "z.number().int()";
      if (field.min !== undefined) zodType += `.min(${field.min})`;
      if (field.max !== undefined) zodType += `.max(${field.max})`;
      break;
    case "boolean":
      zodType = "z.boolean()";
      break;
    case "date":
      zodType = "z.date()";
      break;
    case "uuid":
      zodType = "z.string().uuid()";
      break;
    case "email":
      zodType = "z.string().email()";
      break;
    case "url":
      zodType = "z.string().url()";
      break;
    case "json":
      zodType = "z.record(z.unknown())";
      break;
    case "array":
      const itemType = field.items || "string";
      zodType = `z.array(z.${itemType}())`;
      break;
    case "enum":
      if (field.enum && field.enum.length > 0) {
        const enumValues = field.enum.map((v) => `'${v}'`).join(", ");
        zodType = `z.enum([${enumValues}])`;
      } else {
        zodType = "z.string()";
      }
      break;
    default:
      zodType = "z.unknown()";
  }

  if (!field.required) {
    zodType += ".optional()";
  }

  if (field.default !== undefined) {
    const defaultValue =
      typeof field.default === "string" ? `'${field.default}'` : field.default;
    zodType += `.default(${defaultValue})`;
  }

  return zodType;
}

/**
 * Generate tRPC router from DSL
 */
export const generateTrpcRouter = (schema: JapavelSchema): string => {
  const model = schema.Model;
  const modelLower = model.toLowerCase();
  const apiConfig = parseApiConfig(schema.API);
  const operations = apiConfig.operations;

  let procedures = "";

  if (operations.includes("create")) {
    procedures += generateCreateProcedure(model, modelLower, apiConfig);
  }

  if (operations.includes("read")) {
    procedures += generateReadProcedure(model, modelLower, apiConfig);
  }

  if (operations.includes("update")) {
    procedures += generateUpdateProcedure(model, modelLower, apiConfig);
  }

  if (operations.includes("delete")) {
    procedures += generateDeleteProcedure(model, modelLower, apiConfig);
  }

  if (operations.includes("list")) {
    procedures += generateListProcedure(model, modelLower, apiConfig);
  }

  if (operations.includes("search")) {
    procedures += generateSearchProcedure(model, modelLower, apiConfig);
  }

  return `import { z } from 'zod';
import { router, publicProcedure, protectedProcedure } from '../trpc';
import { TRPCError } from '@trpc/server';
import {
  ${model}Schema,
  Create${model}InputSchema,
  Update${model}InputSchema,
  ${model}QuerySchema,
} from '@japavel/contracts';

/**
 * ${model} Router
 * @generated by Japavel DSL Compiler
 */
export const ${modelLower}Router = router({${procedures}
});

export type ${model}Router = typeof ${modelLower}Router;
`;
};

function parseApiConfig(api: string | ApiConfig | undefined): ApiConfig {
  if (!api) {
    return {
      operations: ["create", "read", "update", "delete", "list"],
      auth: "authenticated",
      pagination: true,
    };
  }

  if (typeof api === "string") {
    // Parse shorthand: "crud", "read-only", "admin"
    switch (api) {
      case "crud":
        return {
          operations: ["create", "read", "update", "delete", "list"],
          auth: "authenticated",
          pagination: true,
        };
      case "read-only":
        return {
          operations: ["read", "list"],
          auth: "public",
          pagination: true,
        };
      case "admin":
        return {
          operations: ["create", "read", "update", "delete", "list"],
          auth: "admin",
          pagination: true,
        };
      default:
        return {
          operations: ["create", "read", "update", "delete", "list"],
          auth: "authenticated",
          pagination: true,
        };
    }
  }

  return api;
}

function getProcedureType(auth: string): string {
  return auth === "public" ? "publicProcedure" : "protectedProcedure";
}

function generateCreateProcedure(
  model: string,
  modelLower: string,
  config: ApiConfig,
): string {
  const procedure = getProcedureType(config.auth);
  return `
  create: ${procedure}
    .input(Create${model}InputSchema)
    .mutation(async ({ input, ctx }) => {
      const ${modelLower} = await ctx.prisma.${modelLower}.create({
        data: input,
      });
      return ${modelLower};
    }),
`;
}

function generateReadProcedure(
  model: string,
  modelLower: string,
  config: ApiConfig,
): string {
  const procedure = getProcedureType(config.auth);
  return `
  getById: ${procedure}
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ input, ctx }) => {
      const ${modelLower} = await ctx.prisma.${modelLower}.findUnique({
        where: { id: input.id },
      });
      if (!${modelLower}) {
        throw new TRPCError({ code: 'NOT_FOUND', message: '${model} not found' });
      }
      return ${modelLower};
    }),
`;
}

function generateUpdateProcedure(
  model: string,
  modelLower: string,
  config: ApiConfig,
): string {
  const procedure = getProcedureType(config.auth);
  return `
  update: ${procedure}
    .input(Update${model}InputSchema)
    .mutation(async ({ input, ctx }) => {
      const { id, ...data } = input;
      const ${modelLower} = await ctx.prisma.${modelLower}.update({
        where: { id },
        data,
      });
      return ${modelLower};
    }),
`;
}

function generateDeleteProcedure(
  model: string,
  modelLower: string,
  config: ApiConfig,
): string {
  const procedure = getProcedureType(config.auth);
  return `
  delete: ${procedure}
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ input, ctx }) => {
      await ctx.prisma.${modelLower}.delete({
        where: { id: input.id },
      });
      return { success: true };
    }),
`;
}

function generateListProcedure(
  model: string,
  modelLower: string,
  config: ApiConfig,
): string {
  const procedure = getProcedureType(config.auth);
  return `
  list: ${procedure}
    .input(${model}QuerySchema.optional())
    .query(async ({ input, ctx }) => {
      const { page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'desc' } = input || {};
      const skip = (page - 1) * limit;

      const [items, total] = await Promise.all([
        ctx.prisma.${modelLower}.findMany({
          skip,
          take: limit,
          orderBy: { [sortBy]: sortOrder },
        }),
        ctx.prisma.${modelLower}.count(),
      ]);

      return {
        items,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
        hasMore: page * limit < total,
      };
    }),
`;
}

function generateSearchProcedure(
  model: string,
  modelLower: string,
  config: ApiConfig,
): string {
  const procedure = getProcedureType(config.auth);
  return `
  search: ${procedure}
    .input(z.object({
      query: z.string().min(1),
      limit: z.number().int().min(1).max(50).default(10),
    }))
    .query(async ({ input, ctx }) => {
      const { query, limit } = input;
      const results = await ctx.prisma.${modelLower}.findMany({
        where: {
          OR: [
            { name: { contains: query, mode: 'insensitive' } },
            { email: { contains: query, mode: 'insensitive' } },
          ],
        },
        take: limit,
      });
      return results;
    }),
`;
}

/**
 * Generate Prisma model from DSL
 */
export const generatePrismaModel = (schema: JapavelSchema): string => {
  const fields = getNormalizedFields(schema);
  const model = schema.Model;

  const fieldLines = Object.entries(fields)
    .map(([name, field]) => {
      const prismaType = fieldToPrisma(field);
      const modifiers: string[] = [];

      if (name === "id") {
        modifiers.push("@id @default(uuid())");
      }
      if (field.unique) {
        modifiers.push("@unique");
      }
      if (name === "createdAt") {
        modifiers.push("@default(now())");
      }
      if (name === "updatedAt") {
        modifiers.push("@updatedAt");
      }
      if (
        field.default !== undefined &&
        name !== "createdAt" &&
        name !== "updatedAt"
      ) {
        const defaultVal =
          typeof field.default === "string"
            ? `"${field.default}"`
            : field.default;
        modifiers.push(`@default(${defaultVal})`);
      }

      const modifierStr = modifiers.length > 0 ? " " + modifiers.join(" ") : "";
      const optionalMark = !field.required && name !== "id" ? "?" : "";

      return `  ${name} ${prismaType}${optionalMark}${modifierStr}`;
    })
    .join("\n");

  // Add relationship fields if present
  let relationLines = "";
  if (schema.Relations) {
    relationLines =
      "\n" +
      Object.entries(schema.Relations)
        .map(([name, relation]) => {
          const rel = relation as Relationship;
          switch (rel.type) {
            case "hasOne":
              return `  ${name} ${rel.model}?`;
            case "hasMany":
              return `  ${name} ${rel.model}[]`;
            case "belongsTo":
              const fk = rel.foreignKey || `${name}Id`;
              return `  ${name} ${rel.model} @relation(fields: [${fk}], references: [id])\n  ${fk} String`;
            case "manyToMany":
              return `  ${name} ${rel.model}[]`;
            default:
              return "";
          }
        })
        .join("\n");
  }

  return `/**
 * ${model} Model
 * @generated by Japavel DSL Compiler
 */
model ${model} {
${fieldLines}${relationLines}
}
`;
};

function fieldToPrisma(field: FieldDefinition): string {
  switch (field.type) {
    case "string":
    case "email":
    case "url":
    case "uuid":
      return "String";
    case "number":
      return "Float";
    case "int":
      return "Int";
    case "boolean":
      return "Boolean";
    case "date":
      return "DateTime";
    case "json":
      return "Json";
    case "array":
      return "String[]";
    case "enum":
      return "String";
    default:
      return "String";
  }
}

/**
 * Generate React component from DSL
 */
export const generateReactComponent = (schema: JapavelSchema): string => {
  const model = schema.Model;
  const modelLower = model.toLowerCase();
  const fields = getNormalizedFields(schema);
  const viewConfig = parseViewConfig(schema.View);

  const displayFields =
    viewConfig.fields ||
    Object.keys(fields).filter(
      (f) => !["id", "createdAt", "updatedAt"].includes(f),
    );

  const formFields = displayFields
    .map((name) => {
      const field = fields[name];
      if (!field) return "";
      return generateFormField(name, field);
    })
    .filter(Boolean)
    .join("\n");

  const tableColumns = displayFields
    .map((name) => `      { key: '${name}', label: '${capitalize(name)}' },`)
    .join("\n");

  return `import React from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Create${model}InputSchema, type Create${model}Input, type ${model} } from '@japavel/contracts';
import { trpc } from '../utils/trpc';

/**
 * ${model} Components
 * @generated by Japavel DSL Compiler
 */

// Form component for creating/editing
export const ${model}Form: React.FC<{
  defaultValues?: Partial<Create${model}Input>;
  onSuccess?: (data: ${model}) => void;
}> = ({ defaultValues, onSuccess }) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<Create${model}Input>({
    resolver: zodResolver(Create${model}InputSchema),
    defaultValues,
  });

  const createMutation = trpc.${modelLower}.create.useMutation({
    onSuccess: (data) => {
      onSuccess?.(data);
    },
  });

  const onSubmit = (data: Create${model}Input) => {
    createMutation.mutate(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
${formFields}
      <button
        type="submit"
        disabled={isSubmitting}
        className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 disabled:opacity-50"
      >
        {isSubmitting ? 'Saving...' : 'Save ${model}'}
      </button>
    </form>
  );
};

// Table component for listing
export const ${model}Table: React.FC<{
  onRowClick?: (item: ${model}) => void;
}> = ({ onRowClick }) => {
  const { data, isLoading, error } = trpc.${modelLower}.list.useQuery({});

  const columns = [
${tableColumns}
  ];

  if (isLoading) return <div className="p-4">Loading...</div>;
  if (error) return <div className="p-4 text-red-600">Error: {error.message}</div>;

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            {columns.map((col) => (
              <th
                key={col.key}
                className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                {col.label}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {data?.items.map((item) => (
            <tr
              key={item.id}
              onClick={() => onRowClick?.(item)}
              className="hover:bg-gray-50 cursor-pointer"
            >
              {columns.map((col) => (
                <td key={col.key} className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  {String(item[col.key as keyof typeof item] ?? '')}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

// Card component for display
export const ${model}Card: React.FC<{
  data: ${model};
  onEdit?: () => void;
  onDelete?: () => void;
}> = ({ data, onEdit, onDelete }) => {
  return (
    <div className="bg-white shadow rounded-lg p-6">
      <div className="space-y-2">
${displayFields
  .map(
    (name) => `        <div>
          <span className="text-gray-500 text-sm">${capitalize(name)}:</span>
          <span className="ml-2">{String(data.${name} ?? '')}</span>
        </div>`,
  )
  .join("\n")}
      </div>
      <div className="mt-4 flex gap-2">
        {onEdit && (
          <button onClick={onEdit} className="text-blue-600 hover:text-blue-800">
            Edit
          </button>
        )}
        {onDelete && (
          <button onClick={onDelete} className="text-red-600 hover:text-red-800">
            Delete
          </button>
        )}
      </div>
    </div>
  );
};
`;
};

function parseViewConfig(view: string | ViewConfig | undefined): ViewConfig {
  if (!view) {
    return { type: "table" };
  }

  if (typeof view === "string") {
    return { type: view as ViewConfig["type"] };
  }

  return view;
}

function generateFormField(name: string, field: FieldDefinition): string {
  const label = capitalize(name);
  const required = field.required ? "required" : "";

  switch (field.type) {
    case "boolean":
      return `      <label className="flex items-center gap-2">
        <input type="checkbox" {...register('${name}')} className="rounded" />
        <span>${label}</span>
      </label>`;

    case "enum":
      const options = (field.enum || [])
        .map((v) => `          <option value="${v}">${capitalize(v)}</option>`)
        .join("\n");
      return `      <div>
        <label className="block text-sm font-medium text-gray-700">${label}</label>
        <select {...register('${name}')} ${required} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
          <option value="">Select ${label}</option>
${options}
        </select>
        {errors.${name} && <p className="mt-1 text-sm text-red-600">{errors.${name}?.message}</p>}
      </div>`;

    case "date":
      return `      <div>
        <label className="block text-sm font-medium text-gray-700">${label}</label>
        <input type="date" {...register('${name}')} ${required} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
        {errors.${name} && <p className="mt-1 text-sm text-red-600">{errors.${name}?.message}</p>}
      </div>`;

    case "number":
    case "int":
      return `      <div>
        <label className="block text-sm font-medium text-gray-700">${label}</label>
        <input type="number" {...register('${name}', { valueAsNumber: true })} ${required} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
        {errors.${name} && <p className="mt-1 text-sm text-red-600">{errors.${name}?.message}</p>}
      </div>`;

    case "email":
      return `      <div>
        <label className="block text-sm font-medium text-gray-700">${label}</label>
        <input type="email" {...register('${name}')} ${required} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
        {errors.${name} && <p className="mt-1 text-sm text-red-600">{errors.${name}?.message}</p>}
      </div>`;

    case "url":
      return `      <div>
        <label className="block text-sm font-medium text-gray-700">${label}</label>
        <input type="url" {...register('${name}')} ${required} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
        {errors.${name} && <p className="mt-1 text-sm text-red-600">{errors.${name}?.message}</p>}
      </div>`;

    default:
      return `      <div>
        <label className="block text-sm font-medium text-gray-700">${label}</label>
        <input type="text" {...register('${name}')} ${required} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
        {errors.${name} && <p className="mt-1 text-sm text-red-600">{errors.${name}?.message}</p>}
      </div>`;
  }
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate TypeScript types from DSL
 */
export const generateTypes = (schema: JapavelSchema): string => {
  const model = schema.Model;
  const fields = getNormalizedFields(schema);

  const fieldTypes = Object.entries(fields)
    .map(([name, field]) => {
      const tsType = fieldToTypeScript(field);
      const optional = !field.required ? "?" : "";
      return `  ${name}${optional}: ${tsType};`;
    })
    .join("\n");

  return `/**
 * ${model} Types
 * @generated by Japavel DSL Compiler
 */

export interface ${model} {
${fieldTypes}
}

export interface Create${model}Input extends Omit<${model}, 'id' | 'createdAt' | 'updatedAt'> {}

export interface Update${model}Input extends Partial<Create${model}Input> {
  id: string;
}

export interface ${model}ListResponse {
  items: ${model}[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  hasMore: boolean;
}
`;
};

function fieldToTypeScript(field: FieldDefinition): string {
  switch (field.type) {
    case "string":
    case "email":
    case "url":
    case "uuid":
      return "string";
    case "number":
    case "int":
      return "number";
    case "boolean":
      return "boolean";
    case "date":
      return "Date";
    case "json":
      return "Record<string, unknown>";
    case "array":
      return `${field.items || "string"}[]`;
    case "enum":
      if (field.enum && field.enum.length > 0) {
        return field.enum.map((v) => `'${v}'`).join(" | ");
      }
      return "string";
    default:
      return "unknown";
  }
}
